#此包主要是线程、多线程、线程池
01：synchronized关键字(重点：共享资源.一定要定位准确共享资源，然后进行加锁，防止多线程访问出现线程安全问题)：
     01：synchronized锁的对象；
     02：多线程通讯可以通过synchronized+wait+notify进行通讯；
     03：synchronized存在于对象的头部信息中，当synchronized对象时，对象头中进行标识；
     04：synchronized的常用的三种方式： 同步代码块、同步函数、静态同步代码块；
     05： synchronized锁对象，进行包裹的代码，只需要包裹会出现线程安全问题的代码，不要扩大锁的粒度，可能会导致单线程执行(建议使用同步代码块/在业务代码中声明一个方法包裹着线程安全的代码进行同步函数)
     06：synchronized的缺点：不够灵活，不能手动解锁；
     07：jdk1.6对synchronized的优化：
           1.适应自旋锁：
               自旋锁：为了减少线程状态改变带来的消耗 不停地执行当前线程 
           2.锁消除：
              不可能存在共享数据竞争的锁进行消除
           3.锁粗化：
              将连续的加锁 精简到只加一次锁
           4.轻量级锁：
             无竞争条件下 通过CAS消除同步互斥
           5.偏向锁：
            无竞争条件下 消除整个同步互斥，连CAS都不操作；
     
     08：synchronized可重入性：
              01：  就是当线程获取到该锁对象在同步的方法中可以调用该对象其他的同步方法(注意：必须为同一锁对象，否则可能会引发死锁)     
              02： 若对象锁对象有继承关系，子类可以访问父类的同步方法；
     09：synchronized同步方法:
            当程序正在执行出现异常，默认会释放锁，在多线程这会引发线程安全问题，这时一定要捕获异常；
     10：synchronized：
          保证线程的原子性和可见性；
     
     11：volatile和synchronized的区别：
        
           volatile：只保证了多线程可见性；
           synchronized：保证线程的可见性与原子性；
           注意： 若只需要保证可见性建议使用volatile，因为volatile比synchronized更高效；
 2. 多线程：
       01：线程创建的三种方式：继承Thread、实现Runnable、匿名内部类；
       02: 线程阻塞的方式： sleep(有时间期限的阻塞，不释放锁)、wait(无限阻塞，释放锁，可以通过notify进行唤醒)、notify(唤醒等待线程，但不会释放锁)；
            （jdk1.5添加的current并发包 ）
               扩展：lock+condition(多线程进行通讯)：
                                lock: 可以手动加锁，解锁(注意：需要定位准确共享资源)
                                condition(监控对象):与lock组合使用：
                                        condition.await:获取该锁对象的线程等待(会自动释放锁)；
                                        condition.signalAll:唤醒对应的该锁对象等待的线程；
       03：线程安全的问题的缘由：
             
           概念： 
             多个线程同时对一个共享变量进行访问(即可以进行写/读操作)，会导致获取的数据不正确问题，即线程安全问题；
           
           原因：
               因为成员变量存在于主内存中，主内存中的变量为共享的，当线程操作此变量时，需要从主内存拷贝一份到自己的工作内存
               (注意：线程只能在自己的工作内存操作变量)然后在刷新到主内存中，这时该线程可能就发生使用该工作内存的变量，当其它现场对此变量进行修改时，
               此线程无法知晓此变量已修改继续执行，这就导致线程安全问题，这就引出多线程的可见性(volatile关键字的出现)；
           
           volatile：
              01：  多个线程操作了共享的变量，当有线程操作变量使之发生改变写到主内存时，通知其它线程需到主内存中重新获取该变量(抽象化为多线程的可见性)；
              02：  当使用volatile就可以无需加锁，但无法替代synchronized(volatile只保证了可见性)；
           JMM(内存模型)三大特点：      
                 原子性： 指单个线程执行是不能分开；
                 可见性： 指多线程之间可以通过volatile关键字抽象化形象的称为可见性
                 有序性： 指单个线程执行有序；